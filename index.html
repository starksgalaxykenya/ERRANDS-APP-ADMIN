<script>
    // Firebase Configuration
    const firebaseConfig = {
        apiKey: "AIzaSyB-cyGvUm_XZBvP62OpCLoELYK5b8jABig",
        authDomain: "finance-report-246b1.firebaseapp.com",
        projectId: "finance-report-246b1",
        storageBucket: "finance-report-246b1.firebasestorage.app",
        messagingSenderId: "506353861080",
        appId: "1:506353861080:web:b5b2526f2828f380d9b2ad"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();

    // Enable Firestore persistence
    db.enablePersistence().catch(err => {
        console.log('Persistence error:', err);
    });

    // Global Variables
    let currentAdmin = null;
    let adminData = {};
    let charts = {};
    let selectedUserId = null;
    let selectedUserType = null;
    let selectedVerificationId = null;
    let selectedDisputeId = null;
    let selectedTicketId = null;

    // DOM Elements
    const loginPage = document.getElementById('loginPage');
    const adminDashboard = document.getElementById('adminDashboard');
    const pages = document.querySelectorAll('.page');
    const navLinks = document.querySelectorAll('.nav-link');
    const toast = document.getElementById('adminToast');
    const loadingSpinner = document.getElementById('loadingSpinner');

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        initEventListeners();
        updateDateTime();
        setInterval(updateDateTime, 1000);
        
        // Check auth state
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                // Check if user is admin
                try {
                    const adminDoc = await db.collection('admins').doc(user.uid).get();
                    
                    if (adminDoc.exists) {
                        currentAdmin = user;
                        adminData = adminDoc.data();
                        showApp();
                        loadDashboardData();
                    } else {
                        // User exists but is not an admin
                        console.log('User is not an admin');
                        await auth.signOut();
                        showLogin();
                        showLoginError('Access denied. Admin privileges required.');
                    }
                } catch (error) {
                    console.error('Auth check error:', error);
                    await auth.signOut();
                    showLogin();
                }
            } else {
                showLogin();
            }
        });
    });

    // Event Listeners
    function initEventListeners() {
        // Login
        document.getElementById('adminLoginBtn').addEventListener('click', adminLogin);
        
        // Enter key on password field
        document.getElementById('adminPassword').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') adminLogin();
        });
        
        // Navigation
        navLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const page = this.getAttribute('data-page');
                
                if (this.id === 'adminLogoutBtn') {
                    adminLogout();
                } else {
                    showPage(page);
                    
                    navLinks.forEach(l => l.classList.remove('active'));
                    this.classList.add('active');
                    
                    const titleSpan = document.querySelector('#currentPageTitle span');
                    const icon = this.querySelector('i').cloneNode(true);
                    document.querySelector('#currentPageTitle').innerHTML = '';
                    document.querySelector('#currentPageTitle').appendChild(icon);
                    document.querySelector('#currentPageTitle').appendChild(document.createTextNode(' '));
                    document.querySelector('#currentPageTitle').appendChild(document.createTextNode(this.querySelector('span').textContent));
                }
            });
        });
        
        // Search
        document.getElementById('userSearch')?.addEventListener('input', debounce(filterUsers, 300));
        document.getElementById('errandSearch')?.addEventListener('input', debounce(filterErrands, 300));
        
        // Filter buttons
        document.querySelectorAll('[data-user-filter]').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('[data-user-filter]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                filterUsersByType(this.getAttribute('data-user-filter'));
            });
        });
        
        document.querySelectorAll('[data-verification-filter]').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('[data-verification-filter]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                filterVerifications(this.getAttribute('data-verification-filter'));
            });
        });
        
        document.querySelectorAll('[data-errand-filter]').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('[data-errand-filter]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                filterErrandsByStatus(this.getAttribute('data-errand-filter'));
            });
        });
        
        document.querySelectorAll('[data-dispute-filter]').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('[data-dispute-filter]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                filterDisputes(this.getAttribute('data-dispute-filter'));
            });
        });
        
        document.querySelectorAll('[data-ticket-filter]').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('[data-ticket-filter]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                filterTickets(this.getAttribute('data-ticket-filter'));
            });
        });
        
        // Close modals on outside click
        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('active');
            }
        });
    }

    // Admin Login - FIXED VERSION
    async function adminLogin() {
        const email = document.getElementById('adminEmail').value.trim();
        const password = document.getElementById('adminPassword').value;
        
        if (!email || !password) {
            showLoginError('Please enter email and password');
            return;
        }
        
        showLoading();
        
        try {
            // First, try to sign in
            let userCredential;
            try {
                userCredential = await auth.signInWithEmailAndPassword(email, password);
            } catch (signInError) {
                // If user doesn't exist, create new account
                if (signInError.code === 'auth/user-not-found') {
                    try {
                        userCredential = await auth.createUserWithEmailAndPassword(email, password);
                        
                        // Create admin document for new user
                        await db.collection('admins').doc(userCredential.user.uid).set({
                            email: email,
                            name: email.split('@')[0],
                            role: 'super_admin',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            permissions: ['all']
                        });
                        
                        showToast('Admin account created successfully!', 'success');
                    } catch (createError) {
                        console.error('Create account error:', createError);
                        showLoginError('Error creating account: ' + getErrorMessage(createError));
                        hideLoading();
                        return;
                    }
                } else {
                    // Other sign-in error
                    console.error('Sign in error:', signInError);
                    showLoginError('Login failed: ' + getErrorMessage(signInError));
                    hideLoading();
                    return;
                }
            }
            
            // If we get here, we have a user
            const user = userCredential.user;
            
            // Check if admin document exists (for existing users)
            const adminDoc = await db.collection('admins').doc(user.uid).get();
            
            if (!adminDoc.exists) {
                // User exists but is not an admin
                await auth.signOut();
                showLoginError('Access denied. Admin privileges required.');
                hideLoading();
                return;
            }
            
            // Success - user is admin
            currentAdmin = user;
            adminData = adminDoc.data();
            
            showApp();
            loadDashboardData();
            
        } catch (error) {
            console.error('Login error:', error);
            showLoginError('Login failed: ' + getErrorMessage(error));
        } finally {
            hideLoading();
        }
    }

    // Helper function to get user-friendly error messages
    function getErrorMessage(error) {
        const errorCode = error.code;
        switch(errorCode) {
            case 'auth/invalid-email':
                return 'Invalid email address format';
            case 'auth/user-disabled':
                return 'This account has been disabled';
            case 'auth/user-not-found':
                return 'No account found with this email';
            case 'auth/wrong-password':
                return 'Incorrect password';
            case 'auth/email-already-in-use':
                return 'Email already in use';
            case 'auth/weak-password':
                return 'Password should be at least 6 characters';
            case 'auth/network-request-failed':
                return 'Network error. Check your connection';
            case 'auth/too-many-requests':
                return 'Too many failed attempts. Try again later';
            default:
                return error.message || 'An unknown error occurred';
        }
    }

    async function adminLogout() {
        try {
            await auth.signOut();
            showLogin();
            showToast('Logged out successfully', 'success');
        } catch (error) {
            console.error('Logout error:', error);
            showToast('Error logging out', 'error');
        }
    }

    function showLoginError(message) {
        const errorDiv = document.getElementById('loginError');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            errorDiv.style.display = 'none';
        }, 5000);
    }

    // Dashboard Data Loading
    async function loadDashboardData() {
        showLoading();
        
        try {
            await Promise.all([
                loadStats(),
                loadPendingVerifications(),
                loadRecentDisputes(),
                loadAllUsers(),
                loadAllErrands(),
                loadTransactions(),
                loadSupportTickets(),
                loadVerifications(),
                updateBadges(),
                initCharts()
            ]);
        } catch (error) {
            console.error('Load error:', error);
            showToast('Error loading data: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    async function loadStats() {
        try {
            // Get users count
            const usersSnap = await db.collection('users').get();
            const runnersSnap = await db.collection('runners').get();
            document.getElementById('totalUsers').textContent = usersSnap.size + runnersSnap.size;
            
            // Get active runners
            const activeRunners = await db.collection('runners').where('isAvailable', '==', true).get();
            document.getElementById('activeRunners').textContent = activeRunners.size;
            
            // Get errands count
            const errandsSnap = await db.collection('errands').get();
            document.getElementById('totalErrands').textContent = errandsSnap.size;
            
            // Calculate commission
            let totalCommission = 0;
            errandsSnap.forEach(doc => {
                totalCommission += doc.data().serviceFee || 0;
            });
            document.getElementById('totalCommission').textContent = `KSH ${totalCommission.toFixed(2)}`;
            document.getElementById('totalRevenue').textContent = `KSH ${totalCommission.toFixed(2)}`;
            
            // Calculate pending payouts
            const withdrawalsSnap = await db.collection('withdrawals').where('status', '==', 'pending').get();
            let pendingPayouts = 0;
            withdrawalsSnap.forEach(doc => pendingPayouts += doc.data().amount || 0);
            document.getElementById('pendingPayouts').textContent = `KSH ${pendingPayouts.toFixed(2)}`;
        } catch (error) {
            console.error('Stats error:', error);
        }
    }

    async function loadPendingVerifications() {
        try {
            const snapshot = await db.collection('verifications')
                .where('status', '==', 'pending')
                .orderBy('submittedAt', 'desc')
                .limit(5)
                .get();
            
            const tbody = document.getElementById('pendingVerificationsBody');
            tbody.innerHTML = '';
            
            if (snapshot.empty) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center;">No pending verifications</td></tr>';
                return;
            }
            
            snapshot.forEach(doc => {
                const v = doc.data();
                const date = v.submittedAt ? v.submittedAt.toDate().toLocaleDateString() : 'Unknown';
                
                tbody.innerHTML += `
                    <tr>
                        <td>
                            <div class="user-cell">
                                <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(v.runnerName || 'Runner')}&background=667eea&color=fff" class="user-avatar-small">
                                ${v.runnerName || 'Unknown'}
                            </div>
                        </td>
                        <td>${date}</td>
                        <td><span class="status-badge status-pending">Pending</span></td>
                        <td>
                            <button class="action-btn view" onclick="viewVerification('${doc.id}')">View</button>
                            <button class="action-btn approve" onclick="approveVerification('${doc.id}')">Approve</button>
                            <button class="action-btn reject" onclick="rejectVerification('${doc.id}')">Reject</button>
                        </td>
                    </tr>
                `;
            });
        } catch (error) {
            console.error('Load verifications error:', error);
        }
    }

    async function loadRecentDisputes() {
        try {
            const snapshot = await db.collection('disputes')
                .where('status', 'in', ['open', 'escalated'])
                .orderBy('createdAt', 'desc')
                .limit(5)
                .get();
            
            const tbody = document.getElementById('recentDisputesBody');
            tbody.innerHTML = '';
            
            if (snapshot.empty) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No active disputes</td></tr>';
                return;
            }
            
            snapshot.forEach(doc => {
                const d = doc.data();
                const date = d.createdAt ? d.createdAt.toDate().toLocaleDateString() : 'Unknown';
                
                tbody.innerHTML += `
                    <tr>
                        <td>#${doc.id.slice(-6)}</td>
                        <td>${d.clientName || 'Client'} vs ${d.runnerName || 'Runner'}</td>
                        <td>KSH ${(d.amount || 0).toFixed(2)}</td>
                        <td><span class="status-badge status-${d.status}">${d.status.toUpperCase()}</span></td>
                        <td>
                            <button class="action-btn view" onclick="viewDispute('${doc.id}')">Resolve</button>
                        </td>
                    </tr>
                `;
            });
        } catch (error) {
            console.error('Load disputes error:', error);
        }
    }

    async function loadAllUsers() {
        try {
            const usersSnap = await db.collection('users').orderBy('createdAt', 'desc').get();
            const runnersSnap = await db.collection('runners').orderBy('createdAt', 'desc').get();
            
            const tbody = document.getElementById('usersTableBody');
            tbody.innerHTML = '';
            
            usersSnap.forEach(doc => addUserToTable(doc, 'client'));
            runnersSnap.forEach(doc => addUserToTable(doc, 'runner'));
        } catch (error) {
            console.error('Load users error:', error);
        }
    }

    function addUserToTable(doc, type) {
        const user = doc.data();
        const date = user.createdAt ? user.createdAt.toDate().toLocaleDateString() : 'Unknown';
        const status = user.banned ? 'banned' : 'active';
        
        document.getElementById('usersTableBody').innerHTML += `
            <tr data-user-type="${type}" data-user-id="${doc.id}">
                <td>
                    <div class="user-cell">
                        <img src="${user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.name || 'User')}&background=667eea&color=fff`}" class="user-avatar-small">
                        ${user.name || 'Unknown'}
                    </div>
                </td>
                <td>${type === 'runner' ? 'üèÉ Runner' : 'üë§ Client'}</td>
                <td>${user.email || ''}</td>
                <td>${user.phone || 'Not provided'}</td>
                <td>${date}</td>
                <td><span class="status-badge status-${status}">${status.toUpperCase()}</span></td>
                <td>
                    <div class="action-buttons">
                        <button class="action-btn view" onclick="viewUser('${doc.id}', '${type}')">View</button>
                        ${!user.banned ? 
                            `<button class="action-btn ban" onclick="banUser('${doc.id}', '${type}')">Ban</button>` : 
                            `<button class="action-btn approve" onclick="unbanUser('${doc.id}', '${type}')">Unban</button>`
                        }
                    </div>
                </td>
            </tr>
        `;
    }

    async function loadAllErrands() {
        try {
            const snapshot = await db.collection('errands').orderBy('createdAt', 'desc').get();
            const tbody = document.getElementById('errandsTableBody');
            tbody.innerHTML = '';
            
            snapshot.forEach(doc => {
                const e = doc.data();
                const date = e.createdAt ? e.createdAt.toDate().toLocaleDateString() : 'Unknown';
                
                tbody.innerHTML += `
                    <tr>
                        <td>#${doc.id.slice(-6)}</td>
                        <td>${e.errandType || 'Unknown'}</td>
                        <td>${e.clientName || 'Unknown'}</td>
                        <td>${e.assignedRunnerName || 'Not assigned'}</td>
                        <td>KSH ${(e.budget || 0).toFixed(2)}</td>
                        <td>KSH ${(e.serviceFee || 0).toFixed(2)}</td>
                        <td><span class="status-badge status-${e.status}">${e.status.toUpperCase()}</span></td>
                        <td>
                            <button class="action-btn view" onclick="viewErrand('${doc.id}')">View</button>
                        </td>
                    </tr>
                `;
            });
        } catch (error) {
            console.error('Load errands error:', error);
        }
    }

    async function loadTransactions() {
        try {
            const snapshot = await db.collection('transactions').orderBy('createdAt', 'desc').limit(50).get();
            const tbody = document.getElementById('transactionsBody');
            tbody.innerHTML = '';
            
            snapshot.forEach(doc => {
                const t = doc.data();
                const date = t.createdAt ? t.createdAt.toDate().toLocaleString() : 'Unknown';
                
                tbody.innerHTML += `
                    <tr>
                        <td>${date}</td>
                        <td>${t.type ? t.type.replace('_', ' ').toUpperCase() : 'Unknown'}</td>
                        <td>${t.userId?.slice(-6) || 'Unknown'}</td>
                        <td>KSH ${(t.amount || 0).toFixed(2)}</td>
                        <td>KSH ${(t.commission || 0).toFixed(2)}</td>
                        <td><span class="status-badge status-${t.status || 'pending'}">${(t.status || 'pending').toUpperCase()}</span></td>
                    </tr>
                `;
            });
        } catch (error) {
            console.error('Load transactions error:', error);
        }
    }

    async function loadVerifications() {
        try {
            const snapshot = await db.collection('verifications').orderBy('submittedAt', 'desc').get();
            const tbody = document.getElementById('verificationsBody');
            tbody.innerHTML = '';
            
            if (snapshot.empty) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No verifications found</td></tr>';
                return;
            }
            
            snapshot.forEach(doc => {
                const v = doc.data();
                const date = v.submittedAt ? v.submittedAt.toDate().toLocaleDateString() : 'Unknown';
                
                tbody.innerHTML += `
                    <tr>
                        <td>${v.runnerName || 'Unknown'}</td>
                        <td>${date}</td>
                        <td>${v.documents ? '‚úÖ Uploaded' : '‚ùå Missing'}</td>
                        <td><span class="status-badge status-${v.status || 'pending'}">${(v.status || 'pending').toUpperCase()}</span></td>
                        <td>
                            <div class="action-buttons">
                                <button class="action-btn view" onclick="viewVerification('${doc.id}')">View</button>
                                ${v.status === 'pending' ? `
                                    <button class="action-btn approve" onclick="approveVerification('${doc.id}')">Approve</button>
                                    <button class="action-btn reject" onclick="rejectVerification('${doc.id}')">Reject</button>
                                ` : ''}
                            </div>
                        </td>
                    </tr>
                `;
            });
        } catch (error) {
            console.error('Load verifications error:', error);
        }
    }

    async function loadSupportTickets() {
        try {
            const snapshot = await db.collection('support').orderBy('createdAt', 'desc').get();
            const ticketsList = document.getElementById('ticketsList');
            ticketsList.innerHTML = '';
            
            if (snapshot.empty) {
                ticketsList.innerHTML = '<div style="text-align: center; padding: 40px;">No support tickets found</div>';
                return;
            }
            
            snapshot.forEach(doc => {
                const t = doc.data();
                const date = t.createdAt ? t.createdAt.toDate().toLocaleString() : 'Unknown';
                
                ticketsList.innerHTML += `
                    <div class="dispute-card" data-ticket-id="${doc.id}">
                        <div class="dispute-header">
                            <span class="dispute-id">Ticket #${doc.id.slice(-6)}</span>
                            <span class="status-badge status-${t.status || 'open'}">${(t.status || 'open').toUpperCase()}</span>
                        </div>
                        <div><strong>From:</strong> ${t.userName || 'Unknown'}</div>
                        <div><strong>Subject:</strong> ${t.subject || 'No subject'}</div>
                        <div class="dispute-message">${t.message || 'No message'}</div>
                        <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                            <span style="font-size: 12px;">${date}</span>
                            <div>
                                <button class="action-btn view" onclick="viewTicket('${doc.id}')">Respond</button>
                                ${t.status !== 'resolved' ? 
                                    `<button class="action-btn approve" onclick="markTicketResolved('${doc.id}')">Resolve</button>` : ''
                                }
                            </div>
                        </div>
                    </div>
                `;
            });
        } catch (error) {
            console.error('Load tickets error:', error);
        }
    }

    async function updateBadges() {
        try {
            const pendingVerifications = await db.collection('verifications').where('status', '==', 'pending').get();
            document.getElementById('pendingVerificationsBadge').textContent = pendingVerifications.size;
            
            const openDisputes = await db.collection('disputes').where('status', '==', 'open').get();
            document.getElementById('disputesBadge').textContent = openDisputes.size;
            
            const openTickets = await db.collection('support').where('status', '==', 'open').get();
            document.getElementById('supportBadge').textContent = openTickets.size;
            
            const incompleteUsers = await db.collection('users').where('profileComplete', '==', false).get();
            const incompleteRunners = await db.collection('runners').where('profileComplete', '==', false).get();
            document.getElementById('pendingUsersBadge').textContent = incompleteUsers.size + incompleteRunners.size;
        } catch (error) {
            console.error('Update badges error:', error);
        }
    }

    // Chart Functions
    function initCharts() {
        try {
            // Activity Chart
            const activityCtx = document.getElementById('activityChart')?.getContext('2d');
            if (activityCtx && !charts.activity) {
                charts.activity = new Chart(activityCtx, {
                    type: 'line',
                    data: {
                        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
                        datasets: [{
                            label: 'Errands',
                            data: [12, 19, 15, 17, 24, 30, 28],
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
            }
            
            // User Chart
            const userCtx = document.getElementById('userChart')?.getContext('2d');
            if (userCtx && !charts.user) {
                const usersCount = parseInt(document.getElementById('totalUsers').textContent) || 100;
                const runnersCount = parseInt(document.getElementById('activeRunners').textContent) || 35;
                
                charts.user = new Chart(userCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Clients', 'Runners'],
                        datasets: [{
                            data: [usersCount - runnersCount, runnersCount],
                            backgroundColor: ['#667eea', '#10b981']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
            }
            
            // Revenue Chart
            const revenueCtx = document.getElementById('revenueChart')?.getContext('2d');
            if (revenueCtx && !charts.revenue) {
                charts.revenue = new Chart(revenueCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
                        datasets: [{
                            label: 'Revenue',
                            data: [12000, 19000, 15000, 22000, 28000, 35000],
                            backgroundColor: '#667eea'
                        }]
                    }
                });
            }
            
            // Growth Chart
            const growthCtx = document.getElementById('growthChart')?.getContext('2d');
            if (growthCtx && !charts.growth) {
                charts.growth = new Chart(growthCtx, {
                    type: 'line',
                    data: {
                        labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
                        datasets: [{
                            label: 'Users',
                            data: [150, 220, 280, 350, 420, 500],
                            borderColor: '#10b981'
                        }]
                    }
                });
            }
        } catch (error) {
            console.error('Chart initialization error:', error);
        }
    }

    // Filter Functions
    function filterUsers() {
        const searchTerm = document.getElementById('userSearch').value.toLowerCase();
        document.querySelectorAll('#usersTableBody tr').forEach(row => {
            row.style.display = row.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
        });
    }

    function filterUsersByType(type) {
        document.querySelectorAll('#usersTableBody tr').forEach(row => {
            if (type === 'all') row.style.display = '';
            else row.style.display = row.dataset.userType === type ? '' : 'none';
        });
    }

    function filterErrands() {
        const searchTerm = document.getElementById('errandSearch').value.toLowerCase();
        document.querySelectorAll('#errandsTableBody tr').forEach(row => {
            row.style.display = row.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
        });
    }

    function filterErrandsByStatus(status) {
        document.querySelectorAll('#errandsTableBody tr').forEach(row => {
            if (status === 'all') {
                row.style.display = '';
            } else {
                const statusCell = row.querySelector('td:nth-child(7) span');
                if (statusCell) {
                    const rowStatus = statusCell.textContent.toLowerCase();
                    row.style.display = rowStatus === status ? '' : 'none';
                }
            }
        });
    }

    function filterVerifications(status) {
        document.querySelectorAll('#verificationsBody tr').forEach(row => {
            if (status === 'all') {
                row.style.display = '';
            } else {
                const statusCell = row.querySelector('td:nth-child(4) span');
                if (statusCell) {
                    const rowStatus = statusCell.textContent.toLowerCase();
                    row.style.display = rowStatus === status ? '' : 'none';
                }
            }
        });
    }

    function filterDisputes(status) {
        document.querySelectorAll('#disputesList .dispute-card').forEach(card => {
            if (status === 'all') {
                card.style.display = '';
            } else {
                const statusSpan = card.querySelector('.status-badge');
                if (statusSpan) {
                    const cardStatus = statusSpan.textContent.toLowerCase();
                    card.style.display = cardStatus.includes(status) ? '' : 'none';
                }
            }
        });
    }

    function filterTickets(status) {
        document.querySelectorAll('#ticketsList .dispute-card').forEach(card => {
            if (status === 'all') {
                card.style.display = '';
            } else {
                const statusSpan = card.querySelector('.status-badge');
                if (statusSpan) {
                    const cardStatus = statusSpan.textContent.toLowerCase();
                    card.style.display = cardStatus.includes(status) ? '' : 'none';
                }
            }
        });
    }

    // User Actions
    async function viewUser(userId, type) {
        selectedUserId = userId;
        selectedUserType = type;
        
        try {
            const collection = type === 'runner' ? 'runners' : 'users';
            const doc = await db.collection(collection).doc(userId).get();
            
            if (!doc.exists) {
                showToast('User not found', 'error');
                return;
            }
            
            const user = doc.data();
            
            document.getElementById('userModalBody').innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <img src="${user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.name || 'User')}&size=100&background=667eea&color=fff`}" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover;">
                    <h3 style="margin-top: 10px;">${user.name || 'Unknown'}</h3>
                    <p>${type === 'runner' ? 'üèÉ Runner' : 'üë§ Client'}</p>
                </div>
                <div style="display: grid; gap: 10px;">
                    <div><strong>Email:</strong> ${user.email || 'Not provided'}</div>
                    <div><strong>Phone:</strong> ${user.phone || 'Not provided'}</div>
                    <div><strong>Joined:</strong> ${user.createdAt ? user.createdAt.toDate().toLocaleString() : 'Unknown'}</div>
                    <div><strong>Wallet Balance:</strong> KSH ${(user.walletBalance || 0).toFixed(2)}</div>
                    ${type === 'runner' ? `
                        <div><strong>Total Jobs:</strong> ${user.totalJobs || 0}</div>
                        <div><strong>Total Earnings:</strong> KSH ${(user.totalEarnings || 0).toFixed(2)}</div>
                        <div><strong>Rating:</strong> ‚≠ê ${user.rating || '0.0'}</div>
                    ` : `
                        <div><strong>Total Errands:</strong> ${user.totalErrands || 0}</div>
                        <div><strong>Total Spent:</strong> KSH ${(user.totalSpent || 0).toFixed(2)}</div>
                    `}
                    <div><strong>Status:</strong> ${user.banned ? 'üö´ Banned' : '‚úÖ Active'}</div>
                </div>
            `;
            
            document.getElementById('banUserBtn').textContent = user.banned ? 'Unban User' : 'Ban User';
            showModal('userModal');
        } catch (error) {
            console.error('View user error:', error);
            showToast('Error loading user details', 'error');
        }
    }

    async function banUser() {
        if (!selectedUserId || !selectedUserType) return;
        
        const action = document.getElementById('banUserBtn').textContent === 'Unban User' ? 'unban' : 'ban';
        if (!confirm(`Are you sure you want to ${action} this user?`)) return;
        
        showLoading();
        
        try {
            const collection = selectedUserType === 'runner' ? 'runners' : 'users';
            await db.collection(collection).doc(selectedUserId).update({
                banned: action === 'ban',
                ...(action === 'ban' ? { bannedAt: firebase.firestore.FieldValue.serverTimestamp() } : {})
            });
            
            showToast(`User ${action}ned successfully`, 'success');
            closeModal('userModal');
            loadAllUsers();
        } catch (error) {
            console.error('Ban user error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    async function unbanUser(userId, type) {
        selectedUserId = userId;
        selectedUserType = type;
        await banUser();
    }

    // Verification Actions
    async function viewVerification(verificationId) {
        selectedVerificationId = verificationId;
        
        try {
            const doc = await db.collection('verifications').doc(verificationId).get();
            
            if (!doc.exists) {
                showToast('Verification not found', 'error');
                return;
            }
            
            const v = doc.data();
            
            let docsHtml = '';
            if (v.documents) {
                for (let [key, url] of Object.entries(v.documents)) {
                    docsHtml += `
                        <div class="verification-doc">
                            <strong>${key.replace(/([A-Z])/g, ' $1').toUpperCase()}:</strong>
                            <img src="${url}" style="max-width: 100%; margin-top: 10px; border-radius: var(--radius); cursor: pointer;" onclick="window.open('${url}')">
                        </div>
                    `;
                }
            }
            
            document.getElementById('verificationModalBody').innerHTML = `
                <h3>Runner: ${v.runnerName || 'Unknown'}</h3>
                <p><strong>Email:</strong> ${v.runnerEmail || 'Unknown'}</p>
                <p><strong>Submitted:</strong> ${v.submittedAt ? v.submittedAt.toDate().toLocaleString() : 'Unknown'}</p>
                <p><strong>Status:</strong> <span class="status-badge status-${v.status || 'pending'}">${(v.status || 'pending').toUpperCase()}</span></p>
                ${v.rejectionReason ? `<p><strong>Rejection Reason:</strong> ${v.rejectionReason}</p>` : ''}
                <hr style="margin: 20px 0;">
                ${docsHtml || '<p>No documents uploaded</p>'}
            `;
            
            showModal('verificationModal');
        } catch (error) {
            console.error('View verification error:', error);
            showToast('Error loading verification', 'error');
        }
    }

    async function approveVerification(verificationId) {
        const id = verificationId || selectedVerificationId;
        if (!id) return;
        
        showLoading();
        
        try {
            const verificationDoc = await db.collection('verifications').doc(id).get();
            
            if (!verificationDoc.exists) {
                showToast('Verification not found', 'error');
                hideLoading();
                return;
            }
            
            const verification = verificationDoc.data();
            
            await db.collection('verifications').doc(id).update({
                status: 'approved',
                reviewedAt: firebase.firestore.FieldValue.serverTimestamp(),
                reviewedBy: currentAdmin?.uid || 'admin'
            });
            
            if (verification.runnerId) {
                await db.collection('runners').doc(verification.runnerId).update({
                    verificationStatus: 'verified',
                    verifiedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            showToast('Verification approved!', 'success');
            closeModal('verificationModal');
            loadDashboardData();
        } catch (error) {
            console.error('Approve verification error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    async function rejectVerification(verificationId) {
        const id = verificationId || selectedVerificationId;
        if (!id) return;
        
        const reason = prompt('Please provide a reason for rejection:');
        if (!reason) return;
        
        showLoading();
        
        try {
            await db.collection('verifications').doc(id).update({
                status: 'rejected',
                rejectionReason: reason,
                reviewedAt: firebase.firestore.FieldValue.serverTimestamp(),
                reviewedBy: currentAdmin?.uid || 'admin'
            });
            
            showToast('Verification rejected', 'success');
            closeModal('verificationModal');
            loadDashboardData();
        } catch (error) {
            console.error('Reject verification error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    // Dispute Actions
    async function viewDispute(disputeId) {
        selectedDisputeId = disputeId;
        
        try {
            const doc = await db.collection('disputes').doc(disputeId).get();
            
            if (!doc.exists) {
                showToast('Dispute not found', 'error');
                return;
            }
            
            const d = doc.data();
            
            document.getElementById('disputeModalBody').innerHTML = `
                <div class="dispute-header">
                    <span class="dispute-id">Dispute #${disputeId.slice(-6)}</span>
                    <span class="status-badge status-${d.status || 'open'}">${(d.status || 'open').toUpperCase()}</span>
                </div>
                <div style="margin: 15px 0;">
                    <div><strong>Client:</strong> ${d.clientName || 'Unknown'}</div>
                    <div><strong>Runner:</strong> ${d.runnerName || 'Unknown'}</div>
                    <div><strong>Errand ID:</strong> #${d.errandId?.slice(-6) || 'Unknown'}</div>
                    <div><strong>Amount in Escrow:</strong> KSH ${(d.amount || 0).toFixed(2)}</div>
                </div>
                <h4>Client's Claim:</h4>
                <div class="dispute-message">${d.clientMessage || 'No message provided'}</div>
                <h4>Runner's Response:</h4>
                <div class="dispute-message">${d.runnerMessage || 'No response yet'}</div>
                ${d.evidence ? `
                    <h4>Evidence:</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px;">
                        ${Array.isArray(d.evidence) ? d.evidence.map(url => `
                            <img src="${url}" style="width: 100%; height: 100px; object-fit: cover; border-radius: var(--radius); cursor: pointer;" onclick="window.open('${url}')">
                        `).join('') : ''}
                    </div>
                ` : ''}
            `;
            
            showModal('disputeModal');
        } catch (error) {
            console.error('View dispute error:', error);
            showToast('Error loading dispute', 'error');
        }
    }

    async function resolveDispute(ruling) {
        if (!selectedDisputeId) return;
        
        if (!confirm(`Resolve dispute in favor of the ${ruling}? This action cannot be undone.`)) return;
        
        showLoading();
        
        try {
            const disputeDoc = await db.collection('disputes').doc(selectedDisputeId).get();
            
            if (!disputeDoc.exists) {
                showToast('Dispute not found', 'error');
                hideLoading();
                return;
            }
            
            const dispute = disputeDoc.data();
            
            await db.collection('disputes').doc(selectedDisputeId).update({
                status: 'resolved',
                ruling: ruling,
                resolvedAt: firebase.firestore.FieldValue.serverTimestamp(),
                resolvedBy: currentAdmin?.uid || 'admin'
            });
            
            // Update errand status
            if (dispute.errandId) {
                await db.collection('errands').doc(dispute.errandId).update({
                    status: 'completed',
                    disputeRuling: ruling
                });
            }
            
            showToast(`Dispute resolved in favor of ${ruling}`, 'success');
            closeModal('disputeModal');
            loadDashboardData();
        } catch (error) {
            console.error('Resolve dispute error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    async function escalateDispute() {
        if (!selectedDisputeId) return;
        
        showLoading();
        
        try {
            await db.collection('disputes').doc(selectedDisputeId).update({
                status: 'escalated',
                escalatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            showToast('Dispute escalated', 'success');
            closeModal('disputeModal');
            loadDashboardData();
        } catch (error) {
            console.error('Escalate dispute error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    // Ticket Actions
    async function viewTicket(ticketId) {
        selectedTicketId = ticketId;
        
        try {
            const doc = await db.collection('support').doc(ticketId).get();
            
            if (!doc.exists) {
                showToast('Ticket not found', 'error');
                return;
            }
            
            const t = doc.data();
            
            document.getElementById('ticketModalBody').innerHTML = `
                <h3>${t.subject || 'Support Ticket'}</h3>
                <p><strong>From:</strong> ${t.userName || 'Unknown'} (${t.userType || 'User'})</p>
                <p><strong>Date:</strong> ${t.createdAt ? t.createdAt.toDate().toLocaleString() : 'Unknown'}</p>
                <p><strong>Status:</strong> <span class="status-badge status-${t.status || 'open'}">${(t.status || 'open').toUpperCase()}</span></p>
                <div class="dispute-message">${t.message || 'No message'}</div>
                ${t.response ? `
                    <h4>Previous Response:</h4>
                    <div class="dispute-message" style="background-color: #e3f2fd;">
                        ${t.response}
                    </div>
                    <p style="font-size: 12px; color: var(--gray);">${t.respondedAt ? t.respondedAt.toDate().toLocaleString() : ''}</p>
                ` : ''}
                <div class="form-group" style="margin-top: 20px;">
                    <label class="form-label">Your Response:</label>
                    <textarea id="ticketResponse" class="form-control" rows="4" placeholder="Type your response..."></textarea>
                </div>
            `;
            
            showModal('ticketModal');
        } catch (error) {
            console.error('View ticket error:', error);
            showToast('Error loading ticket', 'error');
        }
    }

    async function respondToTicket() {
        const response = document.getElementById('ticketResponse')?.value;
        if (!response) {
            showToast('Please enter a response', 'warning');
            return;
        }
        
        showLoading();
        
        try {
            await db.collection('support').doc(selectedTicketId).update({
                response: response,
                respondedAt: firebase.firestore.FieldValue.serverTimestamp(),
                respondedBy: currentAdmin?.uid || 'admin',
                status: 'in-progress'
            });
            
            showToast('Response sent successfully', 'success');
            closeModal('ticketModal');
            loadSupportTickets();
        } catch (error) {
            console.error('Respond to ticket error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    async function markTicketResolved(ticketId) {
        const id = ticketId || selectedTicketId;
        if (!id) return;
        
        showLoading();
        
        try {
            await db.collection('support').doc(id).update({
                status: 'resolved',
                resolvedAt: firebase.firestore.FieldValue.serverTimestamp(),
                resolvedBy: currentAdmin?.uid || 'admin'
            });
            
            showToast('Ticket marked as resolved', 'success');
            closeModal('ticketModal');
            loadSupportTickets();
        } catch (error) {
            console.error('Resolve ticket error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    // Settings Functions
    async function saveCommissionSettings() {
        const settings = {
            defaultCommission: parseFloat(document.getElementById('defaultCommission').value),
            deliveryCommission: parseFloat(document.getElementById('deliveryCommission').value),
            shoppingCommission: parseFloat(document.getElementById('shoppingCommission').value),
            minCommission: parseFloat(document.getElementById('minCommission').value),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedBy: currentAdmin?.uid || 'admin'
        };
        
        showLoading();
        
        try {
            await db.collection('settings').doc('commission').set(settings, { merge: true });
            showToast('Commission settings saved', 'success');
        } catch (error) {
            console.error('Save commission error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    async function saveSystemSettings() {
        const settings = {
            minBudget: parseFloat(document.getElementById('minBudget').value),
            newUserBonus: parseFloat(document.getElementById('newUserBonus').value),
            disputeTime: parseInt(document.getElementById('disputeTime').value),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedBy: currentAdmin?.uid || 'admin'
        };
        
        showLoading();
        
        try {
            await db.collection('settings').doc('system').set(settings, { merge: true });
            showToast('System settings saved', 'success');
        } catch (error) {
            console.error('Save system settings error:', error);
            showToast('Error: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    // Utility Functions
    function updateDateTime() {
        const now = new Date();
        document.getElementById('currentDateTime').textContent = now.toLocaleString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }

    function showPage(pageId) {
        pages.forEach(page => page.classList.remove('active'));
        const pageElement = document.getElementById(`${pageId}Page`);
        if (pageElement) {
            pageElement.classList.add('active');
        }
    }

    function showModal(modalId) {
        document.getElementById(modalId).classList.add('active');
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
    }

    function showToast(message, type = 'info') {
        toast.className = `toast ${type}`;
        document.getElementById('toastMessage').textContent = message;
        
        const icon = document.getElementById('toastIcon');
        if (type === 'success') icon.className = 'fas fa-check-circle';
        else if (type === 'error') icon.className = 'fas fa-exclamation-circle';
        else if (type === 'warning') icon.className = 'fas fa-exclamation-triangle';
        else icon.className = 'fas fa-info-circle';
        
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }

    function showLoading() {
        loadingSpinner.style.display = 'flex';
    }

    function hideLoading() {
        loadingSpinner.style.display = 'none';
    }

    function showApp() {
        loginPage.style.display = 'none';
        adminDashboard.style.display = 'flex';
        document.getElementById('adminName').textContent = adminData?.name || 'Admin';
    }

    function showLogin() {
        loginPage.style.display = 'flex';
        adminDashboard.style.display = 'none';
    }

    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), wait);
        };
    }

    // View Errand placeholder
    function viewErrand(errandId) {
        showToast('View errand details - Coming soon', 'info');
    }

    // Global functions
    window.viewUser = viewUser;
    window.banUser = banUser;
    window.unbanUser = unbanUser;
    window.viewVerification = viewVerification;
    window.approveVerification = approveVerification;
    window.rejectVerification = rejectVerification;
    window.viewDispute = viewDispute;
    window.resolveDispute = resolveDispute;
    window.escalateDispute = escalateDispute;
    window.viewErrand = viewErrand;
    window.viewTicket = viewTicket;
    window.respondToTicket = respondToTicket;
    window.markTicketResolved = markTicketResolved;
    window.saveCommissionSettings = saveCommissionSettings;
    window.saveSystemSettings = saveSystemSettings;
    window.showPage = showPage;
    window.showModal = showModal;
    window.closeModal = closeModal;
</script>
